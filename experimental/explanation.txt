Your task is to generate a Tree-sitter query and transformation string in a TOML file that refactors a given original code snippet into a refactored code snippet.
You will be provided with the original code snippet, the refactored code snippet, and the Tree-sitter representations of both.
The TOML file should contain at least one rule with the following properties:

- "query": Tree-sitter query to find the code pattern to refactor
- "replace_node": The captured node in the query that will be replaced
- "replace_string": Replacement string or pattern for the refactored code
- "holes": Placeholders in your queries that will be instantiated at runtime

Additionally, the rule can have optional properties such as "is_seed_rule", "groups", and "filters".
Filters can have properties like "enclosing_node", "not_contains", "contains", "at_least", "at_most".


Here's an example of a TOML file with a single rule, including explanations for each property:

<file_name_start> your_rules_file.toml <file_name_end>
```toml
# Rule definition
[[rules]]
# Name of the rule
name = "your_rule_name"

# Tree-sitter query to find the code pattern to refactor
query = """
(
    (your_code_pattern) @your_capture_name
)
"""

# Replacement string or pattern for the refactored code
replace = "your_replacement_pattern"

# The captured node in the query that will be replaced
replace_node = "your_capture_name"

# Holes to be used in the rule. These are placeholders in your queries that will be instantiated at runtime (can be empty).
holes = ["hole1", "hole2"]

# Optional: Filters to apply for this rule
[[rules.filters]]

# Enclosing node condition for the rule to apply. This means that the match from the query should be enclosed by a parent containing the enclosing node.
enclosing_node = "(your_enclosing_node_pattern) @your_capture_name"

# Conditions for the rule to be applied. This is CHECKED AGAINST ENCLOSING NODE:
#    i. not_contains (set of queries that no children of enclosing node should match)
#    ii. contains (single query that children of enclosing node should match)
#       ii.a at_least (default = 1) (at least n children should match the contains query)
#       ii.b at_most (default = u32::max) (at most n children should match the contains query)

not_contains = [
    """
    (your_not_contains_pattern) @your_capture_name
    """
]
contains =
    """
    (your_contains_pattern) @your_capture_name
    """
at_least = 1
at_most = 5
```

I will now include examples of rules. You can use these as inspiration for your own rules.